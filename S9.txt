#!/usr/bin/env python3
"""
bootstrap_with_tenant.py

Flow:
 1) Read env.json for:
    - BootstrapUrl (preferred) OR host (will add https://)
    - SerialNumber
    - RemoteServiceOwnershipInfo.organization OR organization
    - linuxCaFileName / RootCAName (CA file, optional)
    - optional BootstrapUsername / BootstrapPassword for Basic auth
    - optional tenant id keys: RemoteServiceBootstrapTenantId / TenantId / tenantId
 2) POST {"Serial_number": "<serial>", "organization": "<org>"} to BootstrapUrl
 3) If response JSON contains 'tenant_url' or 'next_url', POST tenant id to that URL:
      {"tenant_id": "<tenant>"}
    else if tenant id present in env, POST {"tenant_id": "<tenant>"} to the same BootstrapUrl
 4) Print the responses and clearly show returned user/password if present.
"""

import json, ssl, http.client, base64, logging, sys
from pathlib import Path
from urllib.parse import urlparse

# --- Logging ---
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")
log = logging.getLogger("bootstrap-tenant")

# --- Paths ---
BASE = Path(__file__).parent
ENV_PATH = BASE / "env.json"

# --- Helpers ---
def load_env():
    if not ENV_PATH.exists():
        log.error("env.json not found in %s", BASE)
        sys.exit(1)
    try:
        return json.loads(ENV_PATH.read_text(encoding="utf-8"))
    except Exception as e:
        log.exception("Failed to parse env.json: %s", e)
        sys.exit(1)

def pick_ca(env):
    for k in ("linuxCaFileName","Linuxcafilename","linuxcafilename","RootCAName","rootCAName","RootCA"):
        v = env.get(k)
        if not v:
            continue
        p = Path(v)
        if p.is_file(): return str(p)
        rp = BASE / v
        if rp.is_file(): return str(rp)
    return None

def get_serial_org(env):
    serial = env.get("SerialNumber") or env.get("serialNumber") or env.get("Serial_number") or env.get("serial_number")
    org = None
    rso = env.get("RemoteServiceOwnershipInfo")
    if isinstance(rso, dict):
        org = rso.get("organization") or rso.get("Organization")
    if not org:
        org = env.get("organization") or env.get("Organization")
    return serial, org

def build_url_exact(env):
    raw = env.get("BootstrapUrl") or env.get("BootstrapAgentUrl") or env.get("bootstrapUrl")
    if raw:
        return raw
    raw = env.get("RemoteServiceBootstrapBrokerHostName") or env.get("BootstrapHost") or env.get("BootstrapServer")
    if not raw:
        return None
    if raw.startswith("http://") or raw.startswith("https://"):
        return raw
    return "https://" + raw

def create_ssl_context(ca_file):
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.check_hostname = True
    ctx.verify_mode = ssl.CERT_REQUIRED
    ctx.options |= ssl.OP_NO_TLSv1
    ctx.options |= ssl.OP_NO_TLSv1_1
    if ca_file:
        ctx.load_verify_locations(cafile=ca_file)
        log.info("Loaded CA file: %s", ca_file)
    else:
        log.info("No CA file provided: using system CA store")
    return ctx

def http_post(url, payload, ca_file=None, basic_user=None, basic_pass=None, timeout=15):
    parsed = urlparse(url)
    scheme = parsed.scheme or "https"
    host = parsed.hostname
    port = parsed.port or (443 if scheme=="https" else 80)
    path = parsed.path or "/"
    if parsed.query:
        path += "?" + parsed.query

    body = json.dumps(payload).encode("utf-8")
    headers = {"Content-Type":"application/json", "Accept":"application/json"}
    if basic_user and basic_pass:
        token = base64.b64encode(f"{basic_user}:{basic_pass}".encode()).decode("ascii")
        headers["Authorization"] = "Basic " + token
        log.info("Using Basic auth for HTTP POST")

    log.info("HTTP POST -> %s (host=%s port=%s path=%s)", url, host, port, path)
    log.info("Payload: %s", json.dumps(payload))

    ctx = create_ssl_context(ca_file)
    conn = None
    try:
        if scheme == "https":
            conn = http.client.HTTPSConnection(host, port=port, context=ctx, timeout=timeout)
        else:
            conn = http.client.HTTPConnection(host, port=port, timeout=timeout)
        conn.request("POST", path, body=body, headers=headers)
        resp = conn.getresponse()
        status = resp.status
        raw = resp.read()
        text = raw.decode("utf-8", errors="replace")
        log.info("HTTP status: %s", status)
        # Try parse JSON
        try:
            j = json.loads(text)
            log.info("Response JSON:\n%s", json.dumps(j, indent=2))
            return status, j
        except Exception:
            log.info("Response text (non-JSON):\n%s", text[:4000])
            return status, text
    finally:
        if conn:
            conn.close()

# --- Main flow ---
def main():
    env = load_env()
    ca = pick_ca(env)
    serial, org = get_serial_org(env)
    if not serial:
        log.error("SerialNumber missing in env.json. Add SerialNumber key.")
        sys.exit(1)

    bootstrap_url = build_url_exact(env)
    if not bootstrap_url:
        log.error("BootstrapUrl / host not found in env.json. Add BootstrapUrl or RemoteServiceBootstrapBrokerHostName.")
        sys.exit(1)

    bs_user = env.get("BootstrapUsername") or env.get("BootstrapUser") or env.get("RemoteServiceBootstrapBrokerUsername")
    bs_pass = env.get("BootstrapPassword") or env.get("BootstrapPass") or env.get("RemoteServiceBootstrapBrokerPassword")

    # 1) POST Serial + org
    initial_payload = {"Serial_number": str(serial), "organization": "" if org is None else str(org)}
    status1, resp1 = http_post(bootstrap_url, initial_payload, ca_file=ca, basic_user=bs_user, basic_pass=bs_pass)

    # If response is not JSON or does not indicate next step, still attempt tenant step if tenant exists
    tenant_id = env.get("RemoteServiceBootstrapTenantId") or env.get("TenantId") or env.get("tenantId") or env.get("tenant")
    # If response contains tenant_url or next_url, use that for tenant submit
    next_url = None
    if isinstance(resp1, dict):
        next_url = resp1.get("tenant_url") or resp1.get("tenantUrl") or resp1.get("next_url") or resp1.get("next") or resp1.get("tenantSubmitUrl")
        # also sometimes response may already contain credentials
        got_user = resp1.get("user_id") or resp1.get("user") or resp1.get("username")
        got_pass = resp1.get("password")
        if got_user and got_pass:
            log.info("Bootstrap already returned credentials: user=%s password=(hidden)", got_user)
            # stop here, success
            return

    # if server asked for tenant or next_url is present, post tenant
    if next_url:
        log.info("Server provided tenant submission URL: %s", next_url)
        tenant_payload = {"tenant_id": tenant_id} if tenant_id else {"tenant_id": ""}
        status2, resp2 = http_post(next_url, tenant_payload, ca_file=ca, basic_user=bs_user, basic_pass=bs_pass)
    elif tenant_id:
        # Try posting tenant to the same bootstrap URL (some servers expect tenant in a second POST to same endpoint)
        log.info("No next_url from server; will POST tenant id to same bootstrap URL")
        tenant_payload = {"tenant_id": tenant_id}
        status2, resp2 = http_post(bootstrap_url, tenant_payload, ca_file=ca, basic_user=bs_user, basic_pass=bs_pass)
    else:
        log.info("No tenant id present in env.json and server did not return a tenant_url. Nothing more to do.")
        return

    # parse credentials from second response
    if isinstance(resp2, dict):
        user = resp2.get("user_id") or resp2.get("user") or resp2.get("username")
        pwd = resp2.get("password")
        tid = resp2.get("tenant_id") or resp2.get("tenantId") or resp2.get("tenant")
        if user and pwd:
            log.info("Received credentials from server:")
            log.info("  username: %s", user)
            log.info("  password: (hidden)")
            if tid:
                log.info("  tenant_id: %s", tid)
            return
        else:
            log.info("Tenant POST returned JSON but no credentials found. Response shown above.")
    else:
        log.info("Tenant POST returned non-JSON response (see logs above).")

if __name__ == "__main__":
    main()
