#!/usr/bin/env python3
"""
bootstrap_connect_fixed.py

- Builds bootstrap POST URL from env.json (multiple key options).
- Honors BootstrapUrl or BootstrapHost + BootstrapPort + BootstrapPath explicitly.
- Uses stdlib http.client + ssl (no requests).
- Prints the exact URL used and the returned JSON.
- Then connects to MQTT using returned credentials (tenant/user).
"""

import base64
import json
import logging
import ssl
import time
from pathlib import Path
from urllib.parse import urlparse

import http.client
import paho.mqtt.client as mqtt

# Logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")
log = logging.getLogger("bootstrap-fixed")

BASE = Path(__file__).parent
ENV_FILE = BASE / "env.json"

def load_json(path: Path):
    if not path.exists():
        log.warning("%s not found", path)
        return {}
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:
        log.error("Failed to parse %s: %s", path.name, e)
        return {}

def find_ca(env):
    linux = env.get("linuxCaFileName") or env.get("Linuxcafilename") or env.get("linuxcafilename")
    root = env.get("RootCAName") or env.get("rootCAName") or env.get("RootCA")
    if linux:
        p = Path(linux)
        if p.is_file(): return str(p)
        rp = BASE / linux
        if rp.is_file(): return str(rp)
    if root:
        p = Path(root)
        if p.is_file(): return str(p)
        rp = BASE / root
        if rp.is_file(): return str(rp)
    return None

def build_bootstrap_url(env):
    """
    Determine the bootstrap URL from env keys — prefer explicit BootstrapUrl.
    Accept patterns:
      - BootstrapUrl (full URL)
      - BootstrapHost + optional BootstrapPort + BootstrapPath
      - BootstrapServer + BootstrapPort + BootstrapPath
      - RemoteServiceBootstrapBrokerHostName + BootstrapPath (fallback)
    Returns full URL string or None.
    """
    # 1) full explicit URL
    url = env.get("BootstrapUrl") or env.get("BootstrapAgentUrl") or env.get("bootstrapUrl")
    if url:
        return url

    # 2) host + port + path variants
    host = env.get("BootstrapHost") or env.get("BootstrapServer") or env.get("RemoteServiceBootstrapBrokerHostName")
    if not host:
        return None

    path = env.get("BootstrapPath") or env.get("BootstrapAgentPath") or env.get("bootstrapPath") or "/bootstrapAgent"

    # host may include scheme or port already
    if host.startswith("http://") or host.startswith("https://"):
        parsed = urlparse(host)
        scheme = parsed.scheme
        hostname = parsed.hostname
        host_port = parsed.port
    else:
        # default scheme https
        scheme = "https"
        # host might include :port
        if ":" in host:
            hostname, port_part = host.split(":", 1)
            try:
                host_port = int(port_part)
            except Exception:
                host_port = None
        else:
            hostname = host
            host_port = None

    # explicit BootstrapPort if provided override
    port = env.get("BootstrapPort") or env.get("bootstrapPort") or env.get("RemoteServiceBootstrapBrokerPort") or env.get("SecureMQTTPort")
    if port is not None:
        try:
            host_port = int(port)
        except Exception:
            log.warning("BootstrapPort provided but not integer: %s", port)

    # build url
    if host_port:
        return f"{scheme}://{hostname}:{host_port}{path}"
    else:
        return f"{scheme}://{hostname}{path}"

def create_ssl_context(ca_file):
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.check_hostname = True
    ctx.verify_mode = ssl.CERT_REQUIRED
    # disable TLSv1.0/1.1
    ctx.options |= ssl.OP_NO_TLSv1
    ctx.options |= ssl.OP_NO_TLSv1_1
    if ca_file:
        ctx.load_verify_locations(cafile=ca_file)
        log.info("Loaded CA file: %s", ca_file)
    else:
        log.info("No CA file provided; using system CA store")
    return ctx

def http_post_json(url, username, password, json_obj, ca_file, timeout=10):
    parsed = urlparse(url)
    scheme = parsed.scheme or "https"
    host = parsed.hostname
    port = parsed.port or (443 if scheme == "https" else 80)
    path = parsed.path or "/"
    if parsed.query:
        path += "?" + parsed.query

    headers = {"Content-Type": "application/json", "Accept": "application/json"}
    if username and password:
        auth_bytes = f"{username}:{password}".encode("utf-8")
        headers["Authorization"] = "Basic " + base64.b64encode(auth_bytes).decode("ascii")
        log.info("Using bootstrap basic auth user=%s", username)
    else:
        log.info("No bootstrap username/password provided; trying anonymous POST")

    body = json.dumps(json_obj).encode("utf-8")
    log.info("HTTP POST -> %s (host=%s port=%s path=%s)", url, host, port, path)

    ctx = create_ssl_context(ca_file)
    if scheme == "https":
        conn = http.client.HTTPSConnection(host, port=port, context=ctx, timeout=timeout)
    else:
        conn = http.client.HTTPConnection(host, port=port, timeout=timeout)

    try:
        conn.request("POST", path, body=body, headers=headers)
        resp = conn.getresponse()
        raw = resp.read()
        text = raw.decode("utf-8", errors="replace")
        log.info("Bootstrap HTTP status: %s", resp.status)
        if resp.status >= 400:
            log.error("Bootstrap error response body: %s", text)
            raise RuntimeError(f"Bootstrap POST failed with HTTP status {resp.status}")
        # try parse JSON
        try:
            j = json.loads(text)
        except Exception:
            log.error("Bootstrap response not JSON: %s", text)
            raise
        log.info("Bootstrap JSON returned: %s", json.dumps(j, indent=2))
        return j
    finally:
        conn.close()

def run_mqtt_connect(broker_host, broker_port, ca_file, mqtt_user, mqtt_password, client_id, tenant_id):
    # build username as tenant/user if tenant_id present (Cumulocity)
    if tenant_id and mqtt_user:
        username = f"{tenant_id}/{mqtt_user}"
    else:
        username = mqtt_user

    log.info("Connecting to MQTT %s:%s as client_id=%s username=%s", broker_host, broker_port, client_id, username)
    client = mqtt.Client(client_id=client_id, protocol=mqtt.MQTTv31, clean_session=True)

    if username and mqtt_password:
        client.username_pw_set(username, mqtt_password)
    else:
        log.warning("No MQTT username/password — broker will likely refuse (rc=5)")

    # TLS context
    tlsctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    tlsctx.check_hostname = True
    tlsctx.verify_mode = ssl.CERT_REQUIRED
    tlsctx.options |= ssl.OP_NO_TLSv1
    tlsctx.options |= ssl.OP_NO_TLSv1_1
    if ca_file:
        tlsctx.load_verify_locations(cafile=ca_file)
        log.info("Loaded CA for MQTT: %s", ca_file)

    client.tls_set_context(tlsctx)
    client.tls_insecure_set(False)

    def on_connect(c, userdata, flags, rc):
        code_map = {0:"ok",1:"unacceptable protocol",2:"id rejected",3:"server unavailable",4:"bad user/pw",5:"not authorized"}
        log.info("on_connect rc=%s -> %s", rc, code_map.get(rc, "unknown"))
        if rc == 0:
            payload = {"SerialNumber": client_id, "Timestamp": int(time.time())}
            c.publish("s/us", json.dumps(payload), qos=1)
            log.info("Published bootstrap payload")
            c.subscribe(f"device/{client_id}/#")

    def on_message(c, userdata, msg):
        try:
            txt = msg.payload.decode("utf-8", errors="replace")
            log.info("Message on %s: %s", msg.topic, txt)
        except Exception:
            log.exception("message decode failed")

    def on_disconnect(c, userdata, rc):
        log.warning("Disconnected rc=%s", rc)

    client.on_connect = on_connect
    client.on_message = on_message
    client.on_disconnect = on_disconnect

    try:
        client.connect(broker_host, int(broker_port), keepalive=60)
    except Exception as e:
        log.exception("MQTT socket connect failed: %s", e)
        return

    try:
        client.loop_forever()
    except KeyboardInterrupt:
        log.info("Interrupted by user - disconnecting")
        client.disconnect()

def main():
    env = load_json(ENV_FILE)
    ca_file = find_ca(env)

    # build bootstrap URL (explicit preferred)
    bootstrap_url = build_bootstrap_url(env)
    if not bootstrap_url:
        log.error("Could not determine bootstrap URL. Add BootstrapUrl OR BootstrapHost + BootstrapPath (+BootstrapPort) to env.json")
        return

    # bootstrap auth keys (possible names)
    bootstrap_user = env.get("BootstrapUsername") or env.get("BootstrapUser") or env.get("BootstrapAgentUser") or env.get("RemoteServiceBootstrapBrokerUsername")
    bootstrap_pass = env.get("BootstrapPassword") or env.get("BootstrapPass") or env.get("RemoteServiceBootstrapBrokerPassword")

    serial = env.get("SerialNumber") or env.get("serialNumber") or "unknown-serial"
    organization = (env.get("RemoteServiceOwnershipInfo") or {}).get("organization") or env.get("organization") or "Service"

    # POST body keys: your doc example shows "Serial_number" and "organization"
    body_obj = {"Serial_number": serial, "organization": organization}

    # 1) call bootstrap
    try:
        resp = http_post_json(bootstrap_url, bootstrap_user, bootstrap_pass, body_obj, ca_file)
    except Exception as e:
        log.error("Bootstrap POST failed: %s", e)
        return

    # expected response keys:
    user = resp.get("user_id") or resp.get("user") or resp.get("username")
    pwd = resp.get("password")
    tenant_url = resp.get("tenant_url") or resp.get("tenantUrl") or resp.get("tenant_url")
    tenant_id = resp.get("tenant_id") or resp.get("tenantId") or resp.get("tenant_id")

    # determine mqtt broker host/port from tenant_url or fallback env
    if tenant_url:
        parsed = urlparse(tenant_url)
        broker_host = parsed.hostname or parsed.path
        broker_port = parsed.port or 8883
    else:
        broker_host = env.get("RemoteServiceBootstrapBrokerHostName") or env.get("MQTTHostname") or "localhost"
        broker_port = int(env.get("SecureMQTTPort") or env.get("RemoteServiceBootstrapBrokerPort") or 8883)

    log.info("Bootstrap returned: user=%s tenant_id=%s tenant_url=%s", bool(user), tenant_id, tenant_url)
    log.info("MQTT broker selected: %s:%s", broker_host, broker_port)

    if not user or not pwd:
        log.error("Bootstrap did not return MQTT credentials (user/password). Aborting.")
        return

    # 2) connect MQTT using tenant/user
    run_mqtt_connect(broker_host, broker_port, ca_file, user, pwd, serial, tenant_id)

if __name__ == "__main__":
    main()
