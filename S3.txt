#!/usr/bin/env python3
"""
register_one_way_tls.py

Simple one-way-TLS bootstrap POST using only the system/explicit CA.
Reads env.json (same folder) for:
 - SerialNumber (or serialNumber / Serial_number)
 - RemoteServiceOwnershipInfo.organization OR organization
 - BootstrapUrl OR BootstrapHost (+ BootstrapPort) + BootstrapPath
 - optional: BootstrapUsername / BootstrapPassword (used as Basic auth if present)
 - optional: linuxCaFileName / Linuxcafilename / RootCAName (CA file path)

Sends POST JSON: {"Serial_number": "<serial>", "organization": "<org>"}
Prints POST URL, HTTP status, response body (parsed JSON when possible).
"""

import json
import base64
import ssl
import http.client
from pathlib import Path
from urllib.parse import urlparse
import logging
import sys

# Logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")
log = logging.getLogger("register-oneway")

BASE = Path(__file__).parent
ENV_PATH = BASE / "env.json"

def load_env():
    if not ENV_PATH.exists():
        log.error("env.json not found in script folder: %s", ENV_PATH)
        return {}
    try:
        return json.loads(ENV_PATH.read_text(encoding="utf-8"))
    except Exception as e:
        log.exception("Failed to read/parse env.json: %s", e)
        return {}

def pick_ca_file(env):
    candidates = [
        env.get("linuxCaFileName"),
        env.get("Linuxcafilename"),
        env.get("linuxcafilename"),
        env.get("RootCAName"),
        env.get("rootCAName"),
        env.get("RootCA"),
    ]
    for c in candidates:
        if not c:
            continue
        p = Path(c)
        if p.is_file():
            return str(p)
        rp = BASE / c
        if rp.is_file():
            return str(rp)
    return None

def build_bootstrap_url(env):
    # Prefer an explicit full URL
    full = env.get("BootstrapUrl") or env.get("BootstrapAgentUrl") or env.get("bootstrapUrl")
    if full:
        return full

    # Fallback to host + optional port + path
    host = env.get("BootstrapHost") or env.get("BootstrapServer") or env.get("RemoteServiceBootstrapBrokerHostName")
    if not host:
        return None
    path = env.get("BootstrapPath") or env.get("BootstrapAgentPath") or env.get("bootstrapPath") or "/bootstrapAgent"
    port = env.get("BootstrapPort") or env.get("bootstrapPort")

    # If host already contains scheme/port
    if host.startswith("http://") or host.startswith("https://"):
        # ensure no duplicate path
        return host.rstrip("/") + path

    # Build with https by default
    if port:
        try:
            p_int = int(port)
            return f"https://{host.rstrip('/')}:{p_int}{path}"
        except Exception:
            log.warning("BootstrapPort present but not integer: %s", port)
            return f"https://{host.rstrip('/')}{path}"
    return f"https://{host.rstrip('/')}{path}"

def create_ssl_context(ca_file):
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.check_hostname = True
    ctx.verify_mode = ssl.CERT_REQUIRED
    # disable old insecure TLS versions
    ctx.options |= ssl.OP_NO_TLSv1
    ctx.options |= ssl.OP_NO_TLSv1_1
    if ca_file:
        ctx.load_verify_locations(cafile=ca_file)
        log.info("Using CA file: %s", ca_file)
    else:
        log.info("No CA file provided – using system CA store")
    return ctx

def post_json(url, payload_obj, ca_file=None, username=None, password=None, timeout=15):
    parsed = urlparse(url)
    scheme = parsed.scheme or "https"
    host = parsed.hostname
    port = parsed.port or (443 if scheme == "https" else 80)
    path = parsed.path or "/"
    if parsed.query:
        path += "?" + parsed.query

    body = json.dumps(payload_obj).encode("utf-8")
    headers = {"Content-Type": "application/json", "Accept": "application/json"}

    if username and password:
        tok = base64.b64encode(f"{username}:{password}".encode("utf-8")).decode("ascii")
        headers["Authorization"] = "Basic " + tok
        log.info("Using Basic auth for bootstrap (username present)")

    log.info("POST -> %s (host=%s port=%s path=%s)", url, host, port, path)
    ctx = create_ssl_context(ca_file)

    conn = None
    try:
        if scheme == "https":
            conn = http.client.HTTPSConnection(host, port=port, context=ctx, timeout=timeout)
        else:
            conn = http.client.HTTPConnection(host, port=port, timeout=timeout)

        conn.request("POST", path, body=body, headers=headers)
        resp = conn.getresponse()
        status = resp.status
        text = resp.read().decode("utf-8", errors="replace")
        log.info("HTTP status: %s", status)
        log.info("Response body:\n%s", text)
        try:
            j = json.loads(text)
            return status, j
        except Exception:
            return status, text
    finally:
        if conn:
            conn.close()

def main():
    env = load_env()
    if not env:
        log.error("env.json empty or unreadable — aborting")
        sys.exit(1)

    # Serial number keys variations
    serial = env.get("SerialNumber") or env.get("serialNumber") or env.get("Serial_number") or env.get("serial_number")
    # organization can be under ownership info or top-level
    org = None
    rso = env.get("RemoteServiceOwnershipInfo")
    if isinstance(rso, dict):
        org = rso.get("organization") or rso.get("Organization")
    org = org or env.get("organization") or env.get("Organization") or ""

    if not serial:
        log.error("SerialNumber not found in env.json (expected keys: SerialNumber / serialNumber / Serial_number). Aborting.")
        sys.exit(1)

    bootstrap_url = build_bootstrap_url(env)
    if not bootstrap_url:
        log.error("Bootstrap URL could not be determined. Set 'BootstrapUrl' or 'BootstrapHost' + 'BootstrapPath' (+ 'BootstrapPort') in env.json.")
        sys.exit(1)

    ca_file = pick_ca_file(env)
    bs_user = env.get("BootstrapUsername") or env.get("BootstrapUser") or env.get("RemoteServiceBootstrapBrokerUsername")
    bs_pass = env.get("BootstrapPassword") or env.get("BootstrapPass") or env.get("RemoteServiceBootstrapBrokerPassword")

    payload = {"Serial_number": str(serial), "organization": str(org)}

    status, resp = post_json(bootstrap_url, payload, ca_file=ca_file, username=bs_user, password=bs_pass)
    log.info("POST completed: HTTP %s", status)
    if isinstance(resp, dict):
        log.info("Parsed JSON response:\n%s", json.dumps(resp, indent=2))
    else:
        log.info("Response (text):\n%s", str(resp))

if __name__ == "__main__":
    main()
