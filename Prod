#!/usr/bin/env python3
"""
bootstrap_then_connect.py

1) Calls the bootstrap REST API (POST /bootstrapAgent) using bootstrap user credentials from env.json.
   Request body: { "Serial_number": "<serial>", "organization": "<org>" }
2) Prints the REST JSON response (user_id, password, tenant_url, tenant_id).
3) Uses returned credentials to connect to Cumulocity MQTT:
   - username: "<tenant_id>/<user_id>"
   - password: returned password
   - client id: SerialNumber from env.json (or returned value)
   - TLS with CA from linuxCaFileName / RootCAName
   - MQTT v3.1 (protocol=mqtt.MQTTv31)
"""
import json
import logging
import ssl
import time
from pathlib import Path
from urllib.parse import urlparse

import requests
import paho.mqtt.client as mqtt

# logging
logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s: %(message)s")
log = logging.getLogger("bootstrap-connect")

BASE = Path(__file__).parent
ENV_FILE = BASE / "env.json"
PROFILE_FILE = BASE / "profile.json"
PERSIST_FILE = BASE / "persist.json"

def load_json(path: Path):
    if not path.exists():
        log.warning("%s not found, using empty", path.name)
        return {}
    try:
        return json.loads(path.read_text(encoding="utf-8"))
    except Exception as e:
        log.error("Failed to read %s: %s", path.name, e)
        return {}

def find_ca(env):
    # try keys in order
    linux = env.get("linuxCaFileName") or env.get("Linuxcafilename") or env.get("linuxcafilename") or env.get("LinuxCaFileName")
    root = env.get("RootCAName") or env.get("rootCAName") or env.get("RootCA")
    if linux:
        p = Path(linux)
        if p.is_file():
            return str(p)
        rp = BASE / linux
        if rp.is_file():
            return str(rp)
    if root:
        p = Path(root)
        if p.is_file():
            return str(p)
        rp = BASE / root
        if rp.is_file():
            return str(rp)
    return None

def build_env_config(env):
    # Where to POST bootstrap request: server base URL and path.
    # Accept either explicit bootstrap url or host+path fields in env.json.
    # Common keys (from your envs) might be:
    #   "BootstrapUrl": "https://master-tenant.example.com/bootstrapAgent"
    # or separate:
    #   "RemoteServiceBootstrapHost": "https://master.example.com"
    #   "BootstrapPath": "/bootstrapAgent"
    bootstrap_url = env.get("BootstrapUrl") or env.get("BootstrapAgentUrl") or env.get("bootstrapUrl")
    # fallback: some projects put the host in RemoteServiceBootstrapBrokerHostName (but that's for mqtt)
    # We'll also allow explicit bootstrapHost + bootstrapPath:
    if not bootstrap_url:
        host = env.get("BootstrapHost") or env.get("BootstrapServer") or env.get("RemoteServiceBootstrapBrokerHostName")
        path = env.get("BootstrapPath") or "/bootstrapAgent"
        if host:
            # ensure host has scheme
            if not host.startswith("http"):
                host = "https://" + host
            bootstrap_url = host.rstrip("/") + path
    # fallback use "https://<RemoteServiceBootstrapBrokerHostName>/bootstrapAgent"
    if not bootstrap_url:
        broker_host = env.get("RemoteServiceBootstrapBrokerHostName") or env.get("MQTTHostname")
        if broker_host:
            candidate = ("https://" + broker_host.rstrip("/")) + "/bootstrapAgent"
            bootstrap_url = candidate

    return {
        "bootstrap_url": bootstrap_url,
        "bootstrap_user": env.get("BootstrapUsername") or env.get("BootstrapUser") or env.get("RemoteServiceBootstrapBrokerUsername"),
        "bootstrap_pass": env.get("BootstrapPassword") or env.get("RemoteServiceBootstrapBrokerPassword"),
        "serial": env.get("SerialNumber") or env.get("serialNumber") or "unknown-serial",
        "organization": (env.get("RemoteServiceOwnershipInfo") or {}).get("organization") or env.get("organization") or "Service"
    }

def call_bootstrap(bootstrap_url, username, password, serial, organization, ca_file):
    """
    POST:
    {
      "Serial_number": "<serial>",
      "organization": "Service"
    }
    Expect JSON response with: user_id, password, tenant_url, tenant_id
    """
    headers = {"Content-Type": "application/json"}
    body = {"Serial_number": str(serial), "organization": str(organization)}
    log.info("Bootstrap POST -> %s", bootstrap_url)
    if username and password:
        auth = (username, password)
        log.info("Using bootstrap auth user=%s", username)
    else:
        auth = None
        log.info("No bootstrap auth provided; trying anonymous POST (may be rejected)")

    try:
        resp = requests.post(bootstrap_url, json=body, headers=headers, auth=auth, verify=ca_file if ca_file else True, timeout=10)
    except Exception as e:
        log.exception("Bootstrap POST failed: %s", e)
        raise

    log.info("Bootstrap response status: %s", resp.status_code)
    try:
        j = resp.json()
    except Exception:
        log.error("Bootstrap response not JSON: %s", resp.text)
        raise

    log.info("Bootstrap response JSON: %s", json.dumps(j, indent=2))
    return j

def create_tls_context(ca_path):
    ctx = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    ctx.verify_mode = ssl.CERT_REQUIRED
    ctx.check_hostname = True
    # disable older TLS versions
    ctx.options |= ssl.OP_NO_TLSv1
    ctx.options |= ssl.OP_NO_TLSv1_1
    if ca_path:
        ctx.load_verify_locations(cafile=ca_path)
        log.info("Loaded CA file for TLS: %s", ca_path)
    else:
        log.info("No CA file provided; using system CA store")
    return ctx

def run_mqtt_connect(broker_host, port, ca_file, mqtt_username, mqtt_password, client_id, tenant_id):
    # MQTT username for Cumulocity should be tenant/user
    mqtt_user = f"{tenant_id}/{mqtt_username}" if tenant_id else mqtt_username

    log.info("Connecting MQTT to %s:%s as client_id=%s username=%s", broker_host, port, client_id, mqtt_user)
    client = mqtt.Client(client_id=client_id, protocol=mqtt.MQTTv31, clean_session=True)

    if mqtt_user and mqtt_password:
        client.username_pw_set(mqtt_user, mqtt_password)
    else:
        log.warning("No mqtt username/password provided â€” connection likely refused")

    tls_ctx = create_tls_context(ca_file)
    client.tls_set_context(tls_ctx)
    client.tls_insecure_set(False)

    def on_connect(c, userdata, flags, rc):
        code_map = {0:"ok",1:"unacceptable protocol",2:"id rejected",3:"server unavailable",4:"bad user/pw",5:"not authorized"}
        log.info("on_connect rc=%s -> %s", rc, code_map.get(rc, "unknown"))
        if rc == 0:
            # example publish
            payload = {"SerialNumber": client_id, "Timestamp": int(time.time())}
            c.publish("s/us", json.dumps(payload), qos=1)
            log.info("Published bootstrap payload")
            # subscribe to a sample topic
            c.subscribe(f"device/{client_id}/#")

    def on_message(c, userdata, msg):
        try:
            txt = msg.payload.decode("utf-8", errors="replace")
            log.info("Message on %s: %s", msg.topic, txt)
        except Exception:
            log.exception("Failed to decode message")

    def on_disconnect(c, userdata, rc):
        log.warning("Disconnected (rc=%s)", rc)

    client.on_connect = on_connect
    client.on_message = on_message
    client.on_disconnect = on_disconnect

    try:
        client.connect(broker_host, int(port), keepalive=60)
    except Exception as e:
        log.exception("MQTT connect failed: %s", e)
        return

    try:
        client.loop_forever()
    except KeyboardInterrupt:
        log.info("Interrupted by user - disconnecting")
        try:
            client.disconnect()
        except Exception:
            pass

def main():
    env = load_json(ENV_FILE)
    cfg = build_env_config(env)
    ca_file = find_ca(env)

    if not cfg["bootstrap_url"]:
        log.error("Cannot determine bootstrap_url from env.json. Please add 'BootstrapUrl' or BootstrapHost + BootstrapPath or RemoteServiceBootstrapBrokerHostName.")
        return

    # 1) Call bootstrap API
    try:
        resp_json = call_bootstrap(cfg["bootstrap_url"], cfg["bootstrap_user"], cfg["bootstrap_pass"],
                                   cfg["serial"], cfg["organization"], ca_file)
    except Exception as e:
        log.error("Bootstrap call failed, aborting.")
        return

    # expected fields in response
    user = resp_json.get("user_id") or resp_json.get("user") or resp_json.get("username")
    pwd = resp_json.get("password")
    tenant_url = resp_json.get("tenant_url") or resp_json.get("tenantUrl") or resp_json.get("tenant_url")
    tenant_id = resp_json.get("tenant_id") or resp_json.get("tenantId") or resp_json.get("tenant_id")

    if not user or not pwd or not tenant_url or not tenant_id:
        log.warning("Bootstrap response missing keys. Found: user=%s pwd=%s tenant_url=%s tenant_id=%s", bool(user), bool(pwd), bool(tenant_url), bool(tenant_id))
        # still proceed if user/pwd present but warn
    else:
        log.info("Bootstrap returned user=%s tenant=%s tenant_url=%s", user, tenant_id, tenant_url)

    # derive mqtt broker host from tenant_url
    if tenant_url:
        parsed = urlparse(tenant_url)
        broker_host = parsed.netloc or parsed.path  # netloc usually hostname:port
        # remove potential trailing port, we will use 8883 unless a port present
        if ":" in broker_host:
            host_only, port_s = broker_host.split(":", 1)
            try:
                broker_port = int(port_s)
            except Exception:
                broker_port = 8883
            broker_host = host_only
        else:
            broker_port = 8883
    else:
        # fallback to env mqtt host if tenant_url not provided
        broker_host = env.get("RemoteServiceBootstrapBrokerHostName") or env.get("MQTTHostname") or "localhost"
        broker_port = int(env.get("SecureMQTTPort") or env.get("RemoteServiceBootstrapBrokerPort") or 8883)

    log.info("MQTT broker host determined: %s:%s", broker_host, broker_port)

    # 2) Use returned credentials to connect via MQTT (tenant_id/user)
    if not user or not pwd:
        log.error("No MQTT credentials returned by bootstrap; aborting MQTT connect.")
        return

    client_id = cfg["serial"]
    run_mqtt_connect(broker_host, broker_port, ca_file, user, pwd, client_id, tenant_id)

if __name__ == "__main__":
    main()
